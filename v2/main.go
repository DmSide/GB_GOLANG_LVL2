package main

import (
	"errors"
	"fmt"
	"strings"
	"github.com/mailru/easyjson"
)

func SQLConverter(sql string, args ...interface{}) (string, []interface{}) {
	var (
		resultArgs []interface{}
		resultSQL  string
	)
	chunks := strings.Split(sql, "?")
	if len(chunks) != len(args)+1 {
		fmt.Println(errors.New("length of sql string and args should be the same"))
	}
	for i, chunk := range chunks {
		resultSQL = resultSQL + chunk
		if i != len(chunks)-1 {
			resultSQL = resultSQL + "?"
		}

		if i >= len(args)-1 {
			continue
		}

		if arr, ok := args[i].([]int); ok {
			for j, val := range arr {
				if j != 0 {
					resultSQL = resultSQL + ",?"
				}

				resultArgs = append(resultArgs, val)
			}
		} else if arr, ok := args[i].([]string); ok {
			for j, val := range arr {
				if j != 0 {
					resultSQL = resultSQL + ",?"
				}

				resultArgs = append(resultArgs, val)
			}
		} else {
			resultArgs = append(resultArgs, args[i])
		}
	}
	return resultSQL, resultArgs
}

type Example struct {
	Mock int
}

//easyjson:json
type EasyJSONStruct struct {
	a int    `json:"a"`
	b string `json:"b"`
	c bool	 `json:"c"`
	d interface{}
	e []interface{}
	f []int
	g []string
	h Example
	i []Example
}

func main() {
	a, b := SQLConverter("SELECT * FROM table WHERE deleted = ? AND id IN(?) AND count < ?", false, []int{1, 6, 234}, 555)
	fmt.Println(a)
	fmt.Println(b)
}

//Напишите функцию, которая на вход получает запрос SQL и произвольные параметры, среди которых могут быть как обычные значения (строка, число) так и слайсы таких значений.
//Позиция каждого переданного параметра в запросе SQL обозначается знаком "?".
//Функция должна вернуть запрос SQL, в котором для каждого параметра-слайса количество знаков "?" будет через запятую размножено до количества элементов слайса, а вторым ответом вернуть слайс из параметров, которые соответствуют новым позициям знаков "?".
//Пример:
//Вызов: func ( "SELECT * FROM table WHERE deleted = ? AND id IN(?) AND count < ?", false, []int{1, 6, 234}, 555 )
//Ответ: "SELECT * FROM table WHERE deleted = ? AND id IN(?,?,?) AND count < ?", []interface{}{ false, 1, 6, 234, 555 }
//
//Сделайте кодогенерацию с помощью easyjson для любой Вашей структуры.

//В качестве завершающего задания нужно выполнить программу поиска дубликатов файлов. Дубликаты файлов - это файлы, которые совпадают по имени файла и по его размеру. Нужно написать консольную программу, которая проверяет наличие дублирующихся файлов.
//Программа должна работать на локальном компьютере и получать на вход путь до директории. Программа должна вывести в стандартный поток вывода список дублирующихся файлов, которые находятся как в директории, так и в поддиректориях директории,  переданной через аргумент командной строки. Данная функция должна работать эффективно при помощи распараллеливания программы
//Программа должна принимать дополнительный ключ - возможность удаления обнаруженных дубликатов файлов после поиска. Дополнительно нужно придумать, как обезопасить пользователей от случайного удаления файлов. В качестве ключей желательно придерживаться общепринятых практик по использованию командных опций.
//Критерии приемки программы:
//Программа компилируется
//Программа выполняет функциональность, описанную выше.
//Программа покрыта тестами
//Программа содержит документацию и примеры использования
//Программа обладает флагом “-h/--help” для краткого объяснения функциональности
//Программа должна уведомлять пользователя об ошибках, возникающих во время выполнения
//Дополнительно можете выполнить следующие задания:
//Написать программу которая по случайному принципу генерирует копии уже имеющихся файлов, относительно указанной директории
//Сравнить производительность программы в однопоточном и многопоточном режимах
